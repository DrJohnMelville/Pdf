using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using System.Xml;
using Melville.INPC;
using Microsoft.CodeAnalysis;

namespace Melville.Postscript.OperationGenerator;

public readonly partial struct CodeGenerator
{
    [FromConstructor] private readonly ISymbol classSymbol;
    [FromConstructor] private readonly IEnumerable<GeneratorAttributeSyntaxContext> 
        methods;
    private readonly Dictionary<string, string> typeMapper = new();
    private readonly StringBuilder output = new();

    partial void OnConstructed()
    {
        StandardMapping();
        LoadMappings();
    }

    private void StandardMapping()
    {
        typeMapper["Melville.Postscript.Interpreter.InterpreterState.OperandStack"] = "engine.OperandStack";
        typeMapper["Melville.Postscript.Interpreter.InterpreterState.ExecutionStack"] = "engine.ExecutionStack";
        typeMapper["Melville.Postscript.Interpreter.InterpreterState.DictionaryStack"] = "engine.DictionaryStack";
        typeMapper["Melville.Postscript.Interpreter.InterpreterState.ResourceLibrary"] = "engine.ResourceLibrary";
        typeMapper["Melville.Postscript.Interpreter.Values.PostscriptValue"] = "engine.OperandStack.Pop()";
        typeMapper["Melville.Postscript.Interpreter.InterpreterState.PostscriptEngine"] = "engine";
    }

    private void LoadMappings()
    {
        foreach (var attr in classSymbol.GetAttributes())
        {
            if (!(attr.AttributeClass?.ToString().Equals(
                    "Melville.Postscript.Interpreter.FunctionLibrary.TypeShortcutAttribute")
                ?? false))
                continue;
            typeMapper[attr.ConstructorArguments[0].Value?.ToString()??""] =
                attr.ConstructorArguments[1].Value?.ToString() ?? "";
        }
    }

    public string CreateCode()
    {
        WritePrefix();
        foreach (var item in methods)
        {
            if (item.TargetSymbol is IMethodSymbol sym) CreateMethodClass(sym);
        }

        WriteAddOperationsMethod();
        WriteSuffix();
        return output.ToString();
    }

    private void WritePrefix()
    {
        output.AppendLine($$"""
                            // Implementation for PostscriptOperatorCollection names {{classSymbol.Name}}
                            // this file was auto-generated by Melville.Postscript.OperationGenerator
                            using Melville.Postscript.Interpreter.Values.Execution;
                            using Melville.Postscript.Interpreter.InterpreterState;
                            using Melville.Postscript.Interpreter.Values;
                            using Melville.Postscript.Interpreter.Values.Composites;
                            using System.Threading.Tasks;
                            using Melville.Parsing.AwaitConfiguration;
                            
                            namespace {{classSymbol.ContainingNamespace}};

                            internal static partial class {{classSymbol.Name}}
                            {
                            """);
    }

    private void WriteSuffix() => output.AppendLine("}");

    private void CreateMethodClass(IMethodSymbol item)
    {
        var strategy = MethodWriter.Classify(item);
        strategy.WriteObjectPrefix(output, item);
        WriteMethodDelegation(item, strategy);
        output.AppendLine($$"""
                                    }
                                }
                            """);
    }



    private void WriteMethodDelegation(IMethodSymbol item, MethodWriter writer)
    {
        CreateParameterVariables(item.Parameters);
        var (prefix, postfix) = item.ReturnsVoid ?
             ("", ";"):
             ("engine.OperandStack.Push(", ");");
        output.Append("            ");
        output.Append(writer.CallPrefix());
        WriteMethodCall(item);
        output.AppendLine(writer.CallPostFix());
    }

    private void CreateParameterVariables(ImmutableArray<IParameterSymbol> parameters)
    {
        for (int i = parameters.Length - 1; i >= 0; i--)
        {
            CreateSingleParameterVariable(i, parameters[i]);
        }
    }

    private void CreateSingleParameterVariable(int i, IParameterSymbol parameter)
    {
        output.AppendLine($"            {parameter.Type} p{i} = {VarForType(parameter.Type)};");
    }

    private string VarForType(ITypeSymbol parameterType)
    {
        var str = parameterType.ToString();
        return typeMapper.TryGetValue(str, out var ret) ? ret : 
            $"engine.OperandStack.Pop().Get<{str}>()";
    }

    private void WriteMethodCall(IMethodSymbol item)
    {
        output.Append(item.Name);
        output.Append("(");
        output.Append(GenerateParameters(item));
        output.Append(")");
    }


    private void WriteAddOperationsMethod()
    {
        output.AppendLine("    public static void AddOperations(IPostscriptDictionary dictionary)");
        output.AppendLine("    {");
        foreach (var method in methods)
        {
            WriteOperatorDeclaration(method);
        }
        output.AppendLine("    }");
    }

    private void WriteOperatorDeclaration(GeneratorAttributeSyntaxContext method)
    {
        foreach (var methodAttribute in method.Attributes)
        {
            output.AppendLine(
                $"""        dictionary.Put("{PostscriptName(methodAttribute)}"u8, PostscriptValueFactory.Create(new {method.TargetSymbol.Name}BuiltInFunctionImpl()));""");
        }
    }

    private string GenerateParameters(ISymbol target) =>
        target is IMethodSymbol methodSym && methodSym.Parameters.Length is not 0
            ? string.Join(", ", Enumerable.Range(0, methodSym.Parameters.Length).Select(i => $"p{i}"))
            : "";

    private static string PostscriptName(AttributeData singleAttr)
    {
        return singleAttr.ConstructorArguments.First().Value?.ToString() ??
               throw new InvalidOperationException("Name is required.");
    }
}