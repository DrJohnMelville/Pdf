using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Melville.Fonts.TableGenerator
{
    public readonly partial struct CodeGenerator
    {
        private readonly ISymbol classSymbol;
        private readonly MemberGenerator[] fields;
        private readonly StringBuilder output = new();

        public CodeGenerator(ISymbol classSymbol, IEnumerable<GeneratorAttributeSyntaxContext> fields)
        {
            this.classSymbol = classSymbol;
            this.fields = fields.Select(MemberGeneratorFactory.Create).ToArray();
        }


        public string CreateCode()
        {
            WritePrefix();
            GenerateReaderConstructor();
            output.AppendLine();
            GenerateLoadAsyncMethod();
            output.AppendLine();
            GenerateSizeMember();
            GenerateLoadStatic();
            WriteSuffix();
            return output.ToString();
        }

        private void GenerateLoadStatic()
        {
            output.AppendLine($"""
                static global::{classSymbol} {InterfaceName()}.LoadStatic(
                    ref global::System.Buffers.SequenceReader<byte> reader)=> new(ref reader);  
            """);
        }

        private void GenerateLoadAsyncMethod()
        {
            var arrays = fields.Where(i => i.IsArray).ToArray();
            switch (arrays.Length)
            {
                case 0:
                    GenerateNoArraysToLoad();
                    break;
                case 1:
                    GenerateLoadSingleArray(arrays[0]);
                    break;
                default:
                    GenerateLoadMultipleArrays(arrays);
                    break;
            }
        }

        private void GenerateNoArraysToLoad() =>
            GenerateLoadAsyncHeader("", "=> global::System.Threading.Tasks.ValueTask.CompletedTask;");

        private  void GenerateLoadSingleArray(MemberGenerator item)
        {
            GenerateLoadAsyncHeader("", "=>");
            item.LoadArrayLine(output, "", "");
        }

        private void GenerateLoadMultipleArrays(MemberGenerator[] arrays)
        {
            GenerateLoadAsyncHeader("async ","\r\n    {");
            foreach (var item in arrays)
            {
                item.LoadArrayLine(output, "await",".CA()");
            }
            output.AppendLine("    }");
        }

        private void GenerateLoadAsyncHeader(string asyncDecl, string postfix) =>
            output.AppendLine($"""
                    {asyncDecl}global::System.Threading.Tasks.ValueTask {InterfaceName()}.LoadAsync(
                    global::System.IO.Pipelines.PipeReader reader) {postfix}
                """);
        private void GenerateReaderConstructor()
        {
            output.AppendLine(
                $"    private {ClassSyntax().Identifier} (ref global::System.Buffers.SequenceReader<byte> reader)");
            output.AppendLine("    {");
            foreach (var item in fields)
            {
                item.ConstructorLine(output);
            }
            output.AppendLine("    }");
        }

        private void GenerateSizeMember() => 
            output.AppendLine($"    static int {InterfaceName()}.StaticSize => {ComputeStaticSize()};");

        private string ComputeStaticSize() => fields.Select(ComputeSizeFor).Sum().ToString();

        private static int ComputeSizeFor(MemberGenerator memberGenerator)
        {
            if (memberGenerator.IsArray) return 0;
            return memberGenerator.TypeName() switch
            {
                "byte" => 1,
                "sbyte" => 1,
                "uint" => 4,
                "int" => 4,
                "ushort" => 2,
                "short" => 2,
                "ulong" => 8,
                "long" => 8,
                "global::Melville.Fonts.SfntParsers.TableParserParts.UInt24" => 3,
                "global::Melville.Fonts.SfntParsers.TableParserParts.FixedPoint<int, long, Melville.Fonts.SfntParsers.TableParserParts.Fixed16>" => 4,
                var x => throw new NotImplementedException($"cannot size type {x}")
            };
        }

        private void WritePrefix()
        {
            var tds = ClassSyntax();
            output.AppendLine($$"""
                // Implementation for Font Table Parser {{classSymbol.Name}}
                // this file was auto-generated by Melville.Fonts.TableGenerator
                using Melville.Parsing.AwaitConfiguration;
                namespace {{classSymbol.ContainingNamespace}};

                {{$"{tds.Modifiers} {tds.Keyword} {tds.Identifier}{tds.TypeParameterList}"}}: {{InterfaceName()}}
                {
                """);
        }

        private string InterfaceName() =>
            $"Melville.Fonts.SfntParsers.TableParserParts.IGeneratedParsable<global::{classSymbol}>";
        
        private TypeDeclarationSyntax ClassSyntax() => 
            (TypeDeclarationSyntax)classSymbol.DeclaringSyntaxReferences[0].GetSyntax();

        private void WriteSuffix() => output.AppendLine("}");
    }
}